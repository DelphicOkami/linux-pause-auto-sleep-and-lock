#!/usr/bin/env python3
"""pause-auto-sleep

Small utility to request an idle inhibition from the session power
management D-Bus interface so automatic suspend and screen locking are
temporarily prevented.

Usage examples:
    pause-auto-sleep "application_name or desktop.entry.name" "reason_for_inhibit"
    pause-auto-sleep         # toggle mode: defaults to inhibitor "User" and reason "Manually enabled"

To show an application icon/name in KDE Plasma widgets, use the desktop
entry name (e.g. `org.kde.konsole`). To locate desktop entry files:
    ls /usr/share/applications ~/.local/share/applications | grep -i YOUR_PROGRAM_NAME
"""

import atexit
import functools
import sys
try:
    import dbus
except ImportError:
    print("Error: python-dbus bindings are required. Install your distro package (e.g. python3-dbus) and try again.", file=sys.stderr)
    sys.exit(1)
import tempfile
import os
import signal
import logging
import time
import argparse
from multiprocessing.connection import Listener, Client
import socket
from enum import Enum
from typing import Callable, Optional, List

_registered_cleanup: List[Callable[[], None]] = []
_atexit_registered = False

def get_all_signals():
    """Return a list of signals that should trigger cleanup handlers.

    This list is used as a sensible default set of signals to register
    for cleanup/exit handling.
    """
    return [signal.SIGINT, signal.SIGTERM, signal.SIGTRAP, signal.SIGABRT, signal.SIGBUS, signal.SIGALRM]

def register_exit_function(fun: Optional[Callable[[], None]] = None, signals: Optional[List[int]] = None):
    """Register a cleanup function to run on normal exit and optionally on signals.

    Usage:
      register_exit_function(my_cleanup)
      register_exit_function(my_cleanup, signals=[signal.SIGINT, signal.SIGTERM])

    Can also be used as a decorator: `@register_exit_function()`
    """
    global _atexit_registered

    def run_cleanup():
        for f in list(_registered_cleanup):
            try:
                f()
            except Exception:
                logging.exception('Error running cleanup function')

    def ensure_atexit():
        global _atexit_registered
        if not _atexit_registered:
            atexit.register(run_cleanup)
            _atexit_registered = True

    def add_and_register(fun_to_add: Callable[[], None], sigs: Optional[List[int]]):
        if not callable(fun_to_add):
            raise TypeError(f'{getattr(fun_to_add, "__name__", "Unknown")} is not callable')
        if fun_to_add not in _registered_cleanup:
            _registered_cleanup.append(fun_to_add)
        ensure_atexit()
        if sigs:
            for sig in sigs:
                old = signal.getsignal(sig)

                def handler(signum, frame, old=old):
                    # Avoid performing potentially blocking cleanup inside the
                    # signal handler. Rely on the atexit-registered
                    # `run_cleanup` to run on normal process exit.
                    if callable(old) and old not in (signal.SIG_DFL, signal.SIG_IGN):
                        try:
                            old(signum, frame)
                        except Exception:
                            logging.exception('Previous signal handler raised')
                    # Raise SystemExit to trigger atexit handlers.
                    sys.exit(signum)

                signal.signal(sig, handler)

    if fun is None:
        def decorator(f):
            add_and_register(f, signals)
            return f

        return decorator
    else:
        add_and_register(fun, signals)
        return fun


class close_reasons(Enum):
    """Reason codes used when requesting an existing inhibitor to close.

    The enum values are sent across the local socket so the running
    instance knows why it was asked to terminate.
    """
    CLOSE_REQUESTED = 1
    NEW_INSTANCE = 2
    SIGNAL_RECEIVED = 3
    CTRL_C = 4
    TERM = 5

    def get_string(reason:close_reasons):
        """Return a human-readable string for a `close_reasons` value.

        Args:
            reason: `close_reasons` enum value.

        Returns:
            A short description string.
        """
        match reason:
            case close_reasons.CLOSE_REQUESTED:
                return "User requested closure"
            case close_reasons.NEW_INSTANCE:
                return "New instance started"
            case close_reasons.SIGNAL_RECEIVED:
                return "Signal received"
            case close_reasons.CTRL_C:
                return "Ctrl + c caught"
            case close_reasons.TERM:
                return "Terminate signal caught"
            case _:
                raise ValueError('Unknown value')

class power_management_inhibitor:
    """Helper to interact with the session power management D-Bus API.

    The implementation calls `Inhibit` and `UnInhibit` on the
    `org.freedesktop.PowerManagement` object path used by some desktop
    environments to control idle inhibition.
    """
    def __init__(self):
        bus = dbus.SessionBus()
        self.power_management_proxy = bus.get_object(
            "org.freedesktop.PowerManagement", "/org/freedesktop/PowerManagement"
        )
    
    def start_inhibit(self, inhibitor: str, reason: str):
        """Request an inhibition and return a cookie.

        Args:
            inhibitor: Application or desktop entry name shown to the session.
            reason: Short text describing why the inhibition is requested.

        Returns:
            The inhibitor cookie (opaque integer) or None on failure.
        """
        try:
            cookie = self.power_management_proxy.Inhibit(inhibitor, reason)
            logging.info("Blocking sleep and screen locking")
            logging.info(f'By: {inhibitor}')
            logging.info(f'Reason: {reason}')
            return cookie
        except Exception:
            logging.exception('Failed to acquire inhibition via D-Bus')
            return None

    def stop_inhibit(self, cookie: dbus.UInt32):
        """Release a previously acquired inhibitor cookie.

        Args:
            cookie: The inhibitor cookie returned by `Inhibit`.
        """
        try:
            self.power_management_proxy.UnInhibit(cookie)
            logging.info("Releasing sleep and screen locking block")
        except Exception:
            logging.exception('Failed to release inhibitor cookie')
    
def close_existing(address, reason:close_reasons):
    """Ask a running instance (if any) to close the inhibitor.

    The function connects to a local `multiprocessing.connection` socket
    and sends a `close` command followed by the numeric reason code.
    If no listener is present the call is silently ignored.
    """
    try:
        conn = Client(*address)
        conn.send("close")
        conn.send(reason.value)
        conn.close()
    except socket.error:
        return

def listen_for_close(address, release_attempted=False):
    """Block and listen on the socket for a close request.

    When a `CLOSE` message is received the numeric reason is read and
    the function returns allowing cleanup to occur. If the socket path
    is stale the first attempt will remove it and retry once.
    """
    try:
        listener = Listener(*address)
        conn = listener.accept()
        while True:
            msg = conn.recv()
            if msg.upper() == 'CLOSE':
                # small pause to ensure the reason integer is transmitted
                time.sleep(0.05)
                reason = conn.recv()
                break
            logging.info(f'Closing due to {close_reasons.get_string(reason)}')
        conn.close()
    except OSError as e:
        if release_attempted == False:
            logging.info('Clearing existing socket')
            release_socket(address[0])
            listen_for_close(address, True)
        else:
            raise e
        

def release_socket(path):
    """Remove the socket file at `path` if it exists.

    This is used to clean up stale UNIX domain socket files left by
    previous runs.
    """
    try:
        if os.path.exists(path):
            os.remove(path)
    except Exception:
        logging.exception('Failed to remove socket file')

def get_socket_cleaner(socket_address, sig):
    """Return a callable that requests a close for a given signal.

    The returned function maps common signals to `close_reasons` and
    asks a running instance to terminate the inhibitor.
    """
    def socket_cleaner():
        match sig:
            case signal.SIGINT:
                reason = close_reasons.CTRL_C
            case signal.SIGTERM:
                reason = close_reasons.TERM
            case _:
                reason = close_reasons.SIGNAL_RECEIVED
        close_existing(socket_address, reason)
    return socket_cleaner

def get_cleanup_function(pm_bus: power_management_inhibitor, cookie: dbus.UInt32):
    """Return a cleanup callable that releases the inhibitor cookie.

    This is suitable for registering with `register_exit_function` or
    `atexit.register` to ensure the inhibitor is released on exit.
    """
    def cleanup():
        pm_bus.stop_inhibit(cookie)
    return cleanup

if __name__ == '__main__':
    logging.basicConfig(format='%(asctime)s %(levelname)s: %(message)s', level=logging.INFO)

    p = argparse.ArgumentParser()
    p.description = "Programatically block screen lock and sleep on linux, specifically KDE plasma"

    p.add_argument("--release", help="Does not block screen lock, instead releasing any existing manual blocks", action='store_true')
    p.add_argument("--verbose", "-v", help="Enable verbose (debug) logging", action='store_true')
    p.add_argument("inhibitor", help="App, or desktop entry name", type=str, nargs='?', default="User")
    p.add_argument("reason", help="Reason to block", type=str, nargs='?', default="Manually enabled")
    args = p.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    socket_path = os.path.join(tempfile.gettempdir(), f'{os.path.basename(__file__)}-{os.getuid()}.socket')
    address = (socket_path, 'AF_UNIX')

    # Ensure socket file cleanup handlers are registered for common signals
    register_exit_function(get_socket_cleaner(address, signal.SIGINT), signals=[signal.SIGINT])
    register_exit_function(get_socket_cleaner(address, signal.SIGTERM), signals=[signal.SIGTERM])

    if args.release:
        close_existing(address, close_reasons.CLOSE_REQUESTED)
        sys.exit(0)

    # Ask any existing instance to exit (makes this run in toggle-style)
    close_existing(address, close_reasons.NEW_INSTANCE)

    inhibitor = power_management_inhibitor()
    cookie = inhibitor.start_inhibit(inhibitor=args.inhibitor, reason=args.reason)

    if cookie is None:
        logging.error('Could not acquire inhibitor; exiting')
        sys.exit(1)

    # Ensure we release cookie on exit
    register_exit_function(get_cleanup_function(inhibitor, cookie))

    listen_for_close(address)